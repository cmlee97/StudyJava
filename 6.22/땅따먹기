땅따먹기 게임을 하려고 합니다. 땅따먹기 게임의 땅(land)은 총 N행 4열로 이루어져 있고, 모든 칸에는 점수가 쓰여 있습니다. 1행부터 땅을 밟으며 한 행씩 내려올 때, 각 행의 4칸 중 한 칸만 밟으면서 내려와야 합니다.
단, 땅따먹기 게임에는 한 행씩 내려올 때, 같은 열을 연속해서 밟을 수 없는 특수 규칙이 있습니다.

예를 들면,

| 1 | 2 | 3 | 5 |

| 5 | 6 | 7 | 8 |

| 4 | 3 | 2 | 1 |

로 땅이 주어졌다면, 1행에서 네번째 칸 (5)를 밟았으면, 2행의 네번째 칸 (8)은 밟을 수 없습니다.

마지막 행까지 모두 내려왔을 때, 얻을 수 있는 점수의 최대값을 return하는 solution 함수를 완성해 주세요. 위 예의 경우, 1행의 네번째 칸 (5), 2행의 세번째 칸 (7), 3행의 첫번째 칸 (4) 땅을 밟아 16점이 최고점이 되므로 16을 return 하면 됩니다.

제한사항
행의 개수 N : 100,000 이하의 자연수
열의 개수는 4개이고, 땅(land)은 2차원 배열로 주어집니다.
점수 : 100 이하의 자연수

이문제의 경우 완전탐색으로 코딩하게되면 시간초과가 됨.
//완전탐색코드
class Solution{
    boolean visit[][];
    int N = 0;
    int ans = 0;
    int Solution(int[][] land){
        visit = new boolean[land.length][4];
        N = land.length;
        int anser = ans;
        return answer;
    }
    public void dfs(int r, int sum, int[][] land){
        if(r==N){
            ans = Math.max(ans, sum);
            return;
        }
        for(int j = 0 ; j < 4 ; j++){
            if(!visit[r][j]{
                sum += land[r][j];
                if(r < N-1) visit[r+1][j] = true;
                dfs(r+1, sum, land);
                if(r < N-1) visit[r+1][j] = false;
                sum -= land[r][j];
            }
        }
    }
}

이 경우에는 동적계획법을 사용해서 해결하기!
동적계획법(DP : Dynamic programming) : 작은 문제들을 풀면서 그 결과를 저장해 나아가면서 전체 문제를 해결하는 알고리즘을 의미.
    해당 알고리즘의 특징은 중복 계산을 줄여서 계산 속도를 높일 수 있으며, 경우의 수가 많은 경우에도 효율적으로 계산할 수 있음.
    일반적으로 재귀적으로 구현되며 Memoization 기법을 사용하여 중복 계산을 피함.
        Memoization : '중복계산'을 피하기 위한 기법으로, 이를 이용하여 이전에 계산된 결과를 저장하고 다음에 동일한 계산이 필요할 때 저장된 결과를 이용하여 중복계산을 피함으로써 성능을 향상시킴.
    EX) 피보나치 수, 최장 공통수열 & 최종 공통 문자열 등
동적계획법 알고리즘 구현 -> 중복계산을 피함으로 성능을 높임
1) 문제를 하위 문제로 쪼개기
2) 하위 문제를 재귀적으로 해결
3) 결과를 저장
4) 저장된 결과를 이용하여 큰 문제를 해결
Memoiztion 구현
1) 입력값에 대한 결과값을 저장할 메모이제이션 테이블을 초기화
2) 함수를 호출할 때, 먼저 메모이제이션 테이블에서 해당 입력값의 결과값이 이미 저자오디어 있는지 확인
3) 저장되어 있으면 해당 결과값을 반환, 저장되어 있지 않으면 계산을 수행하고 그 겨로가를 메모이제이션 테이블에 저장, 계산된 결과값 반환
이때, 메오이제이션 테이블은 해시테이블이나 배열 등을 사용하여 구현
동적계획법의 조건
1) 최적 부분 구조(Optimal Substructure) : '큰 문제의 최적해'가 '작은 문제의 최적해'를 포함하는 성질. 작은 문제의 최적해를 구한 후 그것을 이요하여 큰 문제의 최적해를 구하기
2) 중복 부분 문제(Overlapping Subproblems) : '동일한 작은 문제를 반복적으로 해결'해야 하는 성질.
동적계획법의 종류
1) Top-Down 방식 : 큰 문제를 해결하기 위해 작은 문제를 호출하는 방식(재귀적 호출)
    큰 문제를 작은 문제로 나누어 푸는 분할정복(Divide and Conquer)방식과 비슷, 중복되는 작은 문제를 한번만 풀이 -> 시간 복잡도 감소
    Stack Overflow문제 발생 가능
2) Bottom-Up 방식 : '작은 문제'부터 해결하여 '큰 문제'까지 해결하는 알고리즘 방식
    '계산한 부분 문제'의 결과를 저장해두고 나중에 같은 부분 문제가 나타날 때 다시 계산하지 않고 지정된 값을 사용하여 시간 절역
    재귀적으로 수행 X -> '반복문'을 통하여 문제 해결 하는 방식


//DP
import java.util.*;
class Solution {
    int solution(int[][] land) {
        int answer = 0;
        //반복문을 이용한 Bottom-Up방식의 동적계획법
        //1. 1부터 land의 길이까지 반복
        for(int i = 1 ; i < land.length ; i++){
            //2. 현재 행에 이전 행에서 현재 열과 다른 값 중 가장 큰 값을 찾아 더하기
            land[i][0] += Math.max(land[i-1][1], Math.max(land[i-1][2], land[i-1][3]));
            land[i][1] += Math.max(land[i-1][0], Math.max(land[i-1][2], land[i-1][3]));
            land[i][2] += Math.max(land[i-1][0], Math.max(land[i-1][1], land[i-1][3]));
            land[i][3] += Math.max(land[i-1][0], Math.max(land[i-1][1], land[i-1][2]));
        }    
        //3. 마지막 행의 최댓값 구하기
        for(int i = 0 ; i < 4 ; i++){
            answer = Math.max(answer, land[land.length-1][i]);
        }
        
        return answer;
    }
}
