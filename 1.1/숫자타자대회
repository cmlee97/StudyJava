위와 같은 모양으로 배열된 숫자 자판이 있습니다. 숫자 타자 대회는 이 동일한 자판을 사용하여 숫자로만 이루어진 긴 문자열을 누가 가장 빠르게 타이핑하는지 겨루는 대회입니다.

대회에 참가하려는 민희는 두 엄지 손가락을 이용하여 타이핑을 합니다. 민희는 항상 왼손 엄지를 4 위에, 오른손 엄지를 6 위에 두고 타이핑을 시작합니다.
엄지 손가락을 움직여 다음 숫자를 누르는 데에는 일정 시간이 듭니다. 민희는 어떤 두 숫자를 연속으로 입력하는 시간 비용을 몇몇 가중치로 분류하였습니다.

이동하지 않고 제자리에서 다시 누르는 것은 가중치가 1입니다.
상하좌우로 인접한 숫자로 이동하여 누르는 것은 가중치가 2입니다.
대각선으로 인접한 숫자로 이동하여 누르는 것은 가중치가 3입니다.
같지 않고 인접하지 않은 숫자를 누를 때는 위 규칙에 따라 가중치 합이 최소가 되는 경로를 따릅니다.
예를 들어 1 위에 있던 손가락을 0 으로 이동하여 누르는 것은 2 + 2 + 3 = 7 만큼의 가중치를 갖습니다.
단, 숫자 자판은 버튼의 크기가 작기 때문에 같은 숫자 버튼 위에 동시에 두 엄지 손가락을 올려놓을 수 없습니다.
즉, 어떤 숫자를 눌러야 할 차례에 그 숫자 위에 올려져 있는 손가락이 있다면 반드시 그 손가락으로 눌러야 합니다.

숫자로 이루어진 문자열 numbers가 주어졌을 때 최소한의 시간으로 타이핑을 하는 경우의 가중치 합을 return 하도록 solution 함수를 완성해주세요.

제한사항
1 ≤ numbers의 길이 ≤ 100,000
numbers는 아라비아 숫자로만 이루어진 문자열입니다.

import java.util.*;
class Solution {
    int[][] cost = {
        {1, 7, 6, 7, 5, 4, 5, 3, 2, 3},
        {7, 1, 2, 4, 2, 3, 5, 4, 5, 6},
        {6, 2, 1, 2, 3, 2, 3, 5, 4, 5},
        {7, 4, 2, 1, 5, 3, 2, 6, 5, 4},
        {5, 2, 3, 5, 1, 2, 4, 2, 3, 5},
        {4, 3, 2, 3, 2, 1, 2, 3, 2, 3},
        {5, 5, 3, 2, 4, 2, 1, 5, 3, 2},
        {3, 4, 5, 6, 2, 3, 5, 1, 2, 4},
        {2, 5, 4, 5, 3, 2, 3, 2, 1, 2},
        {3, 6, 5, 4, 5, 3, 2, 4, 2, 1}
    };
    int[][][] dp;
    String array;
    public int solution(String numbers) {
        int answer = 0;
        array = numbers;
        dp = new int[numbers.length()+1][10][10];
        for(int i = 0 ; i < numbers.length()+1 ; i++){
            for(int j = 0 ; j < 10 ; j++){
                //1. dp배열 초기화
                Arrays.fill(dp[i][j], -1);
            }
        }
        //2. 0번째 인덱스, 왼쪽 손가락은 4, 오른쪽 손가락은 6 위치에서 시작
        answer = move(0, 4, 6, numbers.length());
        return answer;
    }
    int move(int index, int left, int right, int length){
        //3. 숫자를 모두 누른 경우, 비용은 0
        if(index == length) return 0;
        //4. 이미 계산한 경우, memoization 이용
        if(dp[index][left][right] != -1) return dp[index][left][right];
        //5. 현재 눌러야 하는 숫자
        int num = array.charAt(index) - '0';
        int result = Integer.MAX_VALUE;
        //6. 오른쪽 손가락을 누르는 경우 , 다음 숫자로 이동하고 비용 더하기
        if(num != right) result = Math.min(move(index+1, num, right, length) + cost[left][num], result);
        //7. 왼쪽 손가락을 누르는 경우 , 다음 숫자로 이동하고 비용 더하기
        if(num != left) result = Math.min(move(index+1, left, num, length) + cost[right][num], result);
        return dp[index][left][right] = result;
    }
}

메모이제이션(Memoization)이란?
메모이제이션은 컴퓨터 프로그램에서 동일한 계산을 반복해야 할 때, 이전에 계산한 결과를 메모리에 저장해 두었다가 꺼내 씀으로써 동일한 계산의 반복 수행을 제거하여 프로그램 실행 속도를 빠르게 하는 기술

간단히 말해, 한 번 계산한 결과를 저장해 놓고, 같은 계산이 다시 필요할 때 저장된 결과를 가져다 쓰는 것을 의미
이를 통해 불필요한 계산을 줄이고 프로그램의 효율성을 높임

중복 계산 방지: 동일한 계산을 반복적으로 수행하는 것을 방지하여 시간 복잡도를 줄임
성능 향상: 불필요한 계산을 줄여 프로그램의 전체적인 실행 속도를 향상
코드 간결화: 동일한 계산 부분을 반복해서 작성하지 않아 코드를 간결하게 만들 수 있음

메모이제이션의 예시
피보나치 수열: 피보나치 수열은 이전 두 항의 합으로 다음 항을 구하는 수열 메모이제이션을 사용하면 이미 계산된 값을 저장해 두어 불필요한 재귀 호출을 줄일 수 있음
동적 계획법: 동적 계획법은 문제를 작은 부분 문제로 나누어 해결하고, 부분 문제의 해를 저장하여 큰 문제의 해를 구하는 알고리즘 기법으로 메모이제이션은 동적 계획법에서 필수적인 기술

메모이제이션을 사용하기 위한 조건
순수 함수: 함수의 결과가 입력 값에만 의존하고, 함수 외부의 상태를 변경하지 않는 함수이어야 함
중복 호출: 같은 입력 값으로 함수가 여러 번 호출되어야 메모이제이션의 효과를 볼 수 있음
메모이제이션 구현 방법
배열: 계산 결과를 배열에 저장하여 인덱스를 통해 값을 조회
해시 테이블: 키-값 쌍으로 저장하여 임의의 입력 값에 대한 결과를 빠르게 찾을 수 있음
결론
메모이제이션은 특정 조건에서 프로그램의 성능을 크게 향상시킬 수 있는 강력한 기법으로 재귀 함수나 동적 계획법 문제를 해결할 때 메모이제이션을 적절히 활용하면 효율적인 알고리즘을 구현할 수 있음
