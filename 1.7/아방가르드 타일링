정우는 예술적 감각이 뛰어난 타일공입니다. 그는 단순한 타일을 활용하여 불규칙하면서도 화려하게 타일링을 하곤 합니다.
어느 날 정우는 가로 길이 n, 세로 길이 3 인 판을 타일링하는 의뢰를 맡았습니다. 아방가르드한 디자인 영감이 떠오른 정우는 다음과 같은 두 가지 종류의 타일로 타일링을 하기로 결정했습니다.
각 타일은 90도씩 회전할 수 있으며 타일의 개수는 제한이 없습니다.
n이 주어졌을 때, 이 두 가지 종류의 타일로 n x 3 크기의 판을 타일링하는 방법의 수를 return 하도록 solution 함수를 완성해주세요.

제한 사항
1 ≤ n ≤ 100,000
결과는 매우 클 수 있으므로 1,000,000,007 로 나눈 나머지를 return합니다.

import java.util.*;
class Solution {
    public int solution(int n) {
        int MOD = 1000000007;
        int answer = 0;
        //1. 길이가 n인 막대를 1개의 조각으로 자른 경우의 수
        long[] dp1 = new long[n+1];
        //2. 길이가 n인 막대를 2개의 조각으로 자른 경우의 수
        long[] dp2 = new long[n+1];
        //3. 길이가 n인 막대를 3개의 조각으로 자른 경우의 수
        long[] dp3 = new long[n+1];
        //4. 길이가 n인 막대를 4개의 조각으로 자른 경우의 수
        long[] dp4 = new long[n+1];
        //5. 길이가 0인 막대를 자르는 경우의 수는 자르지 않으므로 1가지 이다
        dp1[0] = 1;
        
        for(int i = 1 ; i <= n ; i++){
            //6. 1개의 조각으로 자르는 경우
            //7. 길이가 i-1인 막대를 1개로 자르고, 남은 1개의 조각을 그대로 두는 경우
            if(i-1 >= 0) dp1[i] = (dp1[i] + dp1[i-1]) % MOD;
            //8. 길이가 i-2인 막대를 1개로 자르고, 남은 2개의 조각을 각각 1개씩 자르는 경우
            if(i-2 >= 0) dp1[i] = (dp1[i] + dp1[i-2] * 2) % MOD;
            //9. 길이가 i-3인 막대를 1개로 자르고, 남은 3개의 조각을 1개씩 자르는 경우 (3C1 * 2C1 = 6)
            if(i-3 >= 0) dp1[i] = (dp1[i] + dp1[i-3] * 5) % MOD;
            //10. 길이가 i-4인 막대를 1개로 자르고, 남은 4개의 조각을 2개씩 자르는 경우 (4C2 = 6)
            if(i-4 >= 0){
                long diff = (dp1[i-4] * 2) % MOD;
                dp2[i] = (dp2[i-3] + diff) % MOD;
                dp1[i] = (dp1[i] + dp2[i] % MOD);
            }
            //11. 길이가 i-5인 막대를 1개로 자르고, 남은 5개의 조각을 2개씩 자르는 경우 (5C2 = 10)
            if(i-5 >= 0){
                long diff = (dp1[i-5] * 2) % MOD;
                dp3[i] = (dp3[i-3] + diff) % MOD;
                dp1[i] = (dp1[i] + dp3[i] % MOD);
            }
            //12. 길이가 i-6인 막대를 1개로 자르고, 남은 6개의 조각을 2개씩 자르는 경우 (6C2 = 15)
            if(i-6 >= 0){
                long diff = (dp1[i-6] * 4) % MOD;
                dp4[i] = (dp4[i-3] + diff) % MOD;
                dp1[i] = (dp1[i] + dp4[i] % MOD);
            }
            
        }
        answer = Math.toIntExact(dp1[n]);
        return answer;
    }
}

<점화식 계산>

dp1[i]인 경우,
dp1[i-1]: 길이가 i-1인 막대를 1개로 자르고, 남은 1개의 조각을 그대로 두는 경우
dp1[i-2] * 2: 길이가 i-2인 막대를 1개로 자르고, 남은 2개의 조각을 각각 1개씩 자르는 경우
dp1[i-3] * 5: 길이가 i-3인 막대를 1개로 자르고, 남은 3개의 조각을 1개씩 자르는 경우 (3C1 * 2C1 = 6)
dp2[i]: 길이가 i-4인 막대를 1개로 자르고, 남은 4개의 조각을 2개씩 자르는 경우 (4C2 = 6)
dp3[i]: 길이가 i-5인 막대를 1개로 자르고, 남은 5개의 조각을 2개씩 자르는 경우 (5C2 = 10)
dp4[i]: 길이가 i-6인 막대를 1개로 자르고, 남은 6개의 조각을 2개씩 자르는 경우 (6C2 = 15)

dp2[i]인 경우,
dp2[i-3] + (dp1[i-4] * 2): 길이가 i-4인 막대를 1개로 자르고, 남은 4개의 조각을 2개씩 자르는 경우의 수를 누적하여 계산

dp3[i]인 경우,
dp3[i-3] + (dp1[i-5] * 2): 길이가 i-5인 막대를 1개로 자르고, 남은 5개의 조각을 2개씩 자르는 경우의 수를 누적하여 계산

dp4[i]인 경우,
dp4[i-3] + (dp1[i-6] * 4): 길이가 i-6인 막대를 1개로 자르고, 남은 6개의 조각을 2개씩 자르는 경우의 수를 누적하여 계산
