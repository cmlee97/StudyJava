n명의 권투선수가 권투 대회에 참여했고 각각 1번부터 n번까지 번호를 받았습니다. 권투 경기는 1대1 방식으로 진행이 되고, 만약 A 선수가 B 선수보다 실력이 좋다면 A 선수는 B 선수를 항상 이깁니다.
심판은 주어진 경기 결과를 가지고 선수들의 순위를 매기려 합니다. 하지만 몇몇 경기 결과를 분실하여 정확하게 순위를 매길 수 없습니다.

선수의 수 n, 경기 결과를 담은 2차원 배열 results가 매개변수로 주어질 때 정확하게 순위를 매길 수 있는 선수의 수를 return 하도록 solution 함수를 작성해주세요.

제한사항
선수의 수는 1명 이상 100명 이하입니다.
경기 결과는 1개 이상 4,500개 이하입니다.
results 배열 각 행 [A, B]는 A 선수가 B 선수를 이겼다는 의미입니다.
모든 경기 결과에는 모순이 없습니다.

//플로이드-워셜 알고리즘
class Solution {
    public int solution(int n, int[][] results) {
        int answer = 0;
        int[][] floyd = new int[n+1][n+1];
        //1. 결과 배열을 플로이드 배열에 초기화
        for(int i = 0 ; i < results.length ; i++){
            int A = results[i][0];
            int B = results[i][1];
            //2. A가 B를 이겼을 때, floyd[A][B] = 1, floyd[B][A] = -1,
            floyd[A][B] = 1;
            floyd[B][A] = -1;
        }
        //3. 플로이드-워셜 알고리즘
        for(int i = 1 ; i <= n ; i++){
            for(int j = 1 ; j <= n ; j++){
                for(int k =1 ; k <= n ; k++){
                    //4. i가 k를 이기고, k가 j를 이기면 i가 j를 이김
                    if(floyd[i][k] == 1 && floyd[k][j] == 1){
                        floyd[i][j] = 1;
                        floyd[j][i] = -1;
                    }
                    //5. i가 k에게 지고, k가 j에게 지면 i가 j에게 짐
                    if(floyd[i][k] == -1 && floyd[k][j] == -1){
                        floyd[i][j] = -1;
                        floyd[j][i] = 1;
                    }
                }
            }
        }
        //6. 결과확인
        for(int i = 1 ; i <= n ; i++){
            int count = 0;
            for(int j = 1 ; j <= n ; j++){
                //7. i와 j사이의 승패가 결정된 경우, count++
                if(floyd[i][j] != 0) count++;
            }
            //8. 모든 선수와의 승패가 결정된 경우, answer++
            if(count == n-1) answer++;
        }
        return answer;
    }
}
//https://gom20.tistory.com/178



플로이드-워셜 알고리즘
그래프에서 모든 노드 쌍 사이의 최단 경로를 찾는 알고리즘으로 어떤 두 노드를 선택하더라도 그 사이의 가장 짧은 경로를 효율적으로 계산
모든 노드 쌍에 대한 최단 경로 : 단순히 특정 시작점에서 다른 모든 노드로의 최단 경로만 구하는 것이 아니라, 그래프 내의 모든 가능한 노드 쌍에 대한 최단 경로를 한 번에 계산
음수 가중치 간선 허용: 다른 알고리즘과 달리, 간선의 가중치가 음수인 경우에도 사용할 수 있지만, 음수 사이클이 존재하면 알고리즘이 정상적으로 동작하지 않음
간단한 구현: 알고리즘의 개념이 비교적 간단하여 구현하기 쉬움
로이드-워셜 알고리즘의 동작 방식
초기화: 모든 노드 쌍 사이의 거리를 무한대로 초기화하고, 자기 자신으로 가는 거리는 0으로 설정
반복: 모든 노드 k에 대해 다음과 같은 연산을 반복
      모든 노드 쌍 (i, j)에 대해, i에서 k를 거쳐 j로 가는 거리가 i에서 j로 직접 가는 거리보다 짧다면, i에서 j로 가는 거리를 업데이트
최종 결과: 모든 반복이 끝나면, 각 노드 쌍 사이의 최단 거리가 계산되어 저장
