0과 1로 이루어진 2n x 2n 크기의 2차원 정수 배열 arr이 있습니다. 당신은 이 arr을 쿼드 트리와 같은 방식으로 압축하고자 합니다. 구체적인 방식은 다음과 같습니다.

당신이 압축하고자 하는 특정 영역을 S라고 정의합니다.
만약 S 내부에 있는 모든 수가 같은 값이라면, S를 해당 수 하나로 압축시킵니다.
그렇지 않다면, S를 정확히 4개의 균일한 정사각형 영역(입출력 예를 참고해주시기 바랍니다.)으로 쪼갠 뒤, 각 정사각형 영역에 대해 같은 방식의 압축을 시도합니다.
arr이 매개변수로 주어집니다. 위와 같은 방식으로 arr을 압축했을 때, 배열에 최종적으로 남는 0의 개수와 1의 개수를 배열에 담아서 return 하도록 solution 함수를 완성해주세요.

제한사항
arr의 행의 개수는 1 이상 1024 이하이며, 2의 거듭 제곱수 형태를 하고 있습니다. 즉, arr의 행의 개수는 1, 2, 4, 8, ..., 1024 중 하나입니다.
arr의 각 행의 길이는 arr의 행의 개수와 같습니다. 즉, arr은 정사각형 배열입니다.
arr의 각 행에 있는 모든 값은 0 또는 1 입니다.

쿼드 트리 (Quad Tree) : 데이터베이스 검색에 사용되는 트리 구조. 항상 하나의 노드에 4개의 가지로 구성되는 트리 구조로서 구하는 레코드가 나타날 때까지 4개로 나누어서 검색이 행해짐.
                        데이트베이스 겁색에 사용되기도 하며, 2차원 공간을 4분할하여 효율적인 데이터 탐색을 진행
                        일반적으로 쿼드트리는 지형(Terrain)에 사용됨. 큰 덩어리로 큼직하게 검색하고 찾아나가기 때문에 부하를 줄일 수 있음
점(Point)쿼드트리 : 2차원 평면에서 가까운 위치를 효과적으로 찾는데 이용 EX) 지도, 도시
범위(Range)쿼드트리 : 2차원 평면에서 영역을 가진 물체끼리 겹치는지 탐색하는데 사용 
                     EX)게임(플랫포머 게임에서 충돌 처리, 탑다운 뷰에서의 충돌처리 등 2D 평면 공간에서 객체의 충돌처리 감지, 컬링에 사용)
                     충돌처리는 주로 AABB알고리즘을 이용, 쿼드트리가 더욱 효과적 -> 한 물체에 대한 충돌처리를 모든 객체와 일일이 비교할 필요가 없음
                        EX) 이미지 용량, 충돌, 컬링 등 다양한 곳에서의 최적화 기법
동작원리
1. 쿼드 트리의 모든 노드는 고유한 사각형 AABB영역과 객체 목록을 가짐
2. 전체 영역을 감싸는 사각형 AABB 영역을 생성하고 루트 노드로 지정
3. 자식으로 내려갈수록 4개의 자식을 가진 완전 트리 형태를 유지
4. 객체 삽입 : AABB영역을 가진 객체를 노드의 객체 목록에 추가
※깊이를 늘려가면서 분할을 진행 -> 깊이 제한 걸어두기!

class Solution {
    int[] answer = new int[2];
    public int[] solution(int[][] arr) {
        //1. (0,0)좌표와 주어진 배열의 길이를 기준으로 재귀함수 호출
        quad(arr, 0, 0, arr.length);
        return answer;
    }
    //압축 가능 확인 함수
    boolean check(int[][] arr, int x, int y, int size, int num){
        for(int i = x ; i < x + size ; i++){
            for(int j = y ; j < y + size ; j++){
                if(arr[i][j] != num) return false;
            }
        }
        return true;
    }
    //quad함수
    void quad(int[][] arr, int x, int y, int size){
        //2. 받은 좌표에서 주어진 길이만큼 정사각형으로 압축가능한 여부 확인
        if(check(arr, x, y, size, arr[x][y])){
            //3. 압축가능하면, answer증가
            if(arr[x][y] ==1) answer[1]++;
            else answer[0]++;
            return ;
        }
        quad(arr,x, y, size/2);
        quad(arr, x , y+size/2, size/2);
        quad(arr, x+size/2, y, size/2);
        quad(arr, x+size/2, y+size/2, size/2);
    }
}
//https://velog.io/@qodlstjd12/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%BF%BC%EB%93%9C%EC%95%95%EC%B6%95-%ED%9B%84-%EA%B0%9C%EC%88%98-%EC%84%B8%EA%B8%B0-Java
