Heap
문제 설명
매운 것을 좋아하는 Leo는 모든 음식의 스코빌 지수를 K 이상으로 만들고 싶습니다. 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 Leo는 스코빌 지수가 가장 낮은 두 개의 음식을 아래와 같이 특별한 방법으로 섞어 새로운 음식을 만듭니다.

섞은 음식의 스코빌 지수 = 가장 맵지 않은 음식의 스코빌 지수 + (두 번째로 맵지 않은 음식의 스코빌 지수 * 2)
Leo는 모든 음식의 스코빌 지수가 K 이상이 될 때까지 반복하여 섞습니다.
Leo가 가진 음식의 스코빌 지수를 담은 배열 scoville과 원하는 스코빌 지수 K가 주어질 때, 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 섞어야 하는 최소 횟수를 return 하도록 solution 함수를 작성해주세요.

제한 사항
scoville의 길이는 2 이상 1,000,000 이하입니다.
K는 0 이상 1,000,000,000 이하입니다.
scoville의 원소는 각각 0 이상 1,000,000 이하입니다.
모든 음식의 스코빌 지수를 K 이상으로 만들 수 없는 경우에는 -1을 return 합니다.

Heap이란? 우선 순위 큐를 위하여 만들어진 자료구조로 배열을 이용하여 구현 가능
          완전 이진 트리의 일종으로 우선순위큐를 위하여 만들어진 자료구조로
          여러개의 값들 중에서 최댓값이나 최솟값을 빠르게 찾아내도록 만들어진 자료구조
          반정렬 상태를 유지 (부모 노드의 키 값이 자식 노드의 키 값보다 항상 큰(작은) 이진트리를 말함)
          중복된 값을 허용
          배열의 첫번째 인덱스인 0은 사용되지 않으며, 특정 위치의 노드번호는 새로운 노드가 추가되어도 변하지 않음
heap의 종류
    최대힙(max heap) : 부모노드의 키 값이 자식 노드의 키 값보다 크거나 같은 완전이진트리
    최소힙(min heap) : 부모노드의 키 값이 자식 노드의 키 값보다 작거나 같은 완전이진트리
heap에서 부모노드와 자식노드의 관계
    왼쪽자식의 인덱스 = (부모의 인덱스)*2
    오른쪽자식의 인덱스 = (부모의 인덱스)*2+1
    부모의 인덱스  = (자식의 인덱스)/2

우선순위 큐란? 데이터들이 우선순위를 가지고 있으며, 우선순위가 높은 데이터가 먼저 나간다
ex) 시뮬레이션 시스템, 네트워크 트래픽제어, 운영체제에서의 작업 스케쥴링 등
배열, 연결리스트, 힙으로 구현 가능하며 힙이 가장 효율적

import java.util.*;
class Solution {
    public int solution(int[] scoville, int K) {
        int answer = 0;
        //1. 우선순위 큐 선언
         PriorityQueue<Integer> newScoville = new PriorityQueue<>();
        //2. 반복문을 통해 주어진 scoville지수 넣기
        for(int i = 0 ; i < scoville.length ; i++){
            //3. 선언된 우선순위 큐에 삽입
            newScoville.add(scoville[i]);
        }
        //4. 최소값 가져오기 : 우선순위 큐이기에 자동으로 제일 작은 값 추출
        int min = newScoville.peek();
        //5. 최소값이 K보다 작을 때 까지
        while(min < K){
                //6. 최소값이 K보다 작으면서 우선순위 큐의 크기가 2보다 작을 경우 return -1
                if(newScoville.size()<2) return -1;
                //7. 섞은 수 +1
                answer++;
                //8. 새로운 scoville지수 구해서 add
                newScoville.add(newScoville.poll()+(newScoville.poll()*2));
                //9. 새로운 min값 가져오기
                min = newScoville.peek();
        }
        return answer;
    }
}
