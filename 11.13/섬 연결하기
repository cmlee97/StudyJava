n개의 섬 사이에 다리를 건설하는 비용(costs)이 주어질 때, 최소의 비용으로 모든 섬이 서로 통행 가능하도록 만들 때 필요한 최소 비용을 return 하도록 solution을 완성하세요.

다리를 여러 번 건너더라도, 도달할 수만 있으면 통행 가능하다고 봅니다. 예를 들어 A 섬과 B 섬 사이에 다리가 있고, B 섬과 C 섬 사이에 다리가 있으면 A 섬과 C 섬은 서로 통행 가능합니다.

제한사항

섬의 개수 n은 1 이상 100 이하입니다.
costs의 길이는 ((n-1) * n) / 2이하입니다.
임의의 i에 대해, costs[i][0] 와 costs[i] [1]에는 다리가 연결되는 두 섬의 번호가 들어있고, costs[i] [2]에는 이 두 섬을 연결하는 다리를 건설할 때 드는 비용입니다.
같은 연결은 두 번 주어지지 않습니다. 또한 순서가 바뀌더라도 같은 연결로 봅니다. 즉 0과 1 사이를 연결하는 비용이 주어졌을 때, 1과 0의 비용이 주어지지 않습니다.
모든 섬 사이의 다리 건설 비용이 주어지지 않습니다. 이 경우, 두 섬 사이의 건설이 불가능한 것으로 봅니다.
연결할 수 없는 섬은 주어지지 않습니다.

import java.util.*;
class Solution {
    //1. 각 노드의 부모 노드를 저장하는 배열 선언
    int[] parent;
    
    public int solution(int n, int[][] costs) {
        //2. 총 비용을 반환하는 변수
        int answer = 0;
        //3. 크루스칼 알고리즘 사용
        // 가중치 기준 오름차순 정렬
        Arrays.sort(costs, (int[] c1, int[] c2) -> c1[2]-c2[2]);
        
        parent = new int[n];
        //4. 각 노드의 부모 노드를 초기화 -> 자기자신으로 설정
        for(int i = 0 ; i < n ; i++) parent[i] = i;
        
        int total = 0;
        
        for(int[] edge : costs){
            //5. 시작점
            int from = edge[0];
            //6. 끝 노드
            int to = edge[1];
            //7. 비용
            int cost = edge[2];
            //8. 시작노드와 끝노드의 부모노드를 찾기
            int fromParent = findParent(from);
            int toParent = findParent(to);
            //9. 두 노드가 같은 집합에 속하면 사이클 발생으로 연결하지 않음
            if(fromParent == toParent) continue;
            //10. 두 노드를 연결하고 총 비용에 현재 비용 추가
            total += cost;
            //11. 두 노드가 같은 그래프에 속하기 때문에 부모노드 갱신
            parent[toParent] = fromParent;
        }
        answer = total;
        return answer;
    }
    //12. 재귀적으로 부모 노드를 찾는 함수(경로 압축 기법)
    int findParent(int node){
        //13. 부모 노드가 자기 자신인 경우 해당 노드가 루트 노드
        if(parent[node] == node) return node;
        //14. 경로 압축을 통해 부모노드를 직접 연결
        return parent[node] = findParent(parent[node]);
    }
}

크루스칼 알고리즘이란?
크루스칼 알고리즘은 최소 신장 트리(Minimum Spanning Tree)를 찾는 대표적인 알고리즘
최소 신장 트리란, 주어진 그래프에서 모든 정점을 연결하는 트리 중에서 간선들의 가중치 합이 최소인 트리를 의미, 가장 적은 비용으로 모든 정점을 연결하는 방법을 찾는 문제를 해결하는 데 사용

크루스칼 알고리즘의 동작 방식
간선 정렬: 모든 간선을 가중치가 증가하는 순서대로 정렬
집합 초기화: 각 정점을 하나의 집합으로 만들기
간선 선택: 정렬된 간선을 하나씩 순서대로 살펴보면서, 다음 조건을 만족하는 간선을 선택
사이클 형성 X: 선택하려는 간선을 연결하면 사이클이 발생하지 않아야 함. 즉, 두 정점이 이미 같은 집합에 속해 있으면 안 됨
집합 합치기: 선택된 간선의 양 끝 점에 해당하는 두 집합을 합치기
반복: 모든 정점이 하나의 집합으로 합쳐질 때까지 3번과 4번 과정을 반복

코드 설명 (위의 Java 코드 기준)
parent 배열: 각 정점의 부모 노드를 저장하여, 두 정점이 같은 집합에 속하는지 판단하는 데 사용
findParent 함수: 주어진 노드의 루트 노드를 찾는 함수, 경로 압축 기법을 사용하여 효율적으로 루트 노드를 찾기
사이클 판단: 두 정점의 루트 노드가 같다면 이미 같은 집합에 속하는 것이므로 사이클이 발생할 가능성이 있음
집합 합치기: 두 정점의 루트 노드 중 하나를 다른 하나의 부모 노드로 설정하여 두 집합을 합치기

크루스칼 알고리즘의 장점
간단한 구현: 구현하기 쉽고 이해하기 쉬움
유연성: 다양한 문제에 적용가능
효율성: 최적화된 구현을 사용하면 빠르게 해결가능

예시
도시 간 도로 건설: 여러 도시를 연결하는 도로를 건설할 때, 총 건설 비용을 최소화
네트워크 구성: 컴퓨터들을 네트워크로 연결할 때, 전체 네트워크 비용을 최소화
추가 설명
최소 신장 트리: 연결된 그래프에서 모든 정점을 포함하고 사이클이 없는 부분 그래프 중에서 간선의 가중치 합이 최소인 트리를 의미
사이클: 그래프에서 시작 정점과 끝 정점이 같은 경로
집합: 서로 관련된 요소들의 모음
경로 압축: findParent 함수에서 사용되는 기법으로, 트리의 높이를 줄여 find 연산의 시간 복잡도를 개선하는 기법
