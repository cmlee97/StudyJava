//2017 카카오코드 예선
무지를 돌보느라 지친 콘은 한적한 시골의 한 캠핑장에 놀러 갔다. 캠핑장은 텐트를 칠 수 있는 넓은 평지를 제공하고 있는데, 이 평지에는 이미 캠핑장에서 설치해 놓은 n개의 쐐기가 박혀 있다. 캠핑장 이용 고객은 이 쐐기들 중 한 쌍을 골라 다음과 같은 조건을 만족하도록 텐트를 설치해야 한다.

텐트는 직사각형 형태여야 한다.
텐트의 네 면이 정확하게 동, 서, 남, 북을 향해야 한다.
대각에 위치하는 텐트의 두 꼭짓점이 정확하게 선택한 두 개의 쐐기에 위치해야 한다.
텐트가 점유하는 직사각형 영역의 넓이는 0보다는 커야 한다.
텐트가 점유하는 직사각형 영역 내부에 다른 쐐기를 포함하면 안 된다. (다른 쐐기가 경계에 위치하는 경우는 허용함)
캠핑장에서는 위와 같은 조건을 만족하는 위치라면 어디든 고객이 텐트를 설치할 수 있도록 정확한 크기의 텐트를 모두 구비하여 대여해준다고 한다.
당신은 위와 같은 조건을 만족하는 텐트를 설치할 수 있는 쐐기의 쌍의 개수는 총 몇 가지가 될지 궁금해졌다.
n개의 쐐기의 위치가 좌표로 주어질 때, 위의 조건을 만족하는 쐐기의 쌍의 개수를 계산하는 프로그램을 작성하시오. 단, 동서 방향은 x축, 남북 방향은 y축과 평행하다고 가정한다.

입력 형식
입력은 쐐기의 개수를 의미하는 정수 n과, n × 2 크기의 2차원 배열 data로 주어지며, 배열의 각 행은 캠핑장에 설치된 쐐기의 x좌표와 y좌표를 의미한다. 제한 조건은 다음과 같다.

2 <= n <= 5,000
n개의 쐐기는 모두 x좌표 0 이상 2^31-1 이하, y좌표 0 이상 2^31-1 이하에 위치한다.
입력되는 n개의 쐐기 중 x좌표와 y좌표가 모두 같은 경우는 없다.
출력 형식
입력에 주어진 각 케이스에 대해 가능한 텐트의 쐐기의 쌍의 개수를 정수 형태로 리턴한다.

import java.util.*;
class Solution {
    public int solution(int n, int[][] data) {
        int answer = 0;
        //1. x좌표 기준으로 오름차순 정렬
        Arrays.sort(data, (o1, o2) -> {
            //2. x좌표가 같은경우, y좌표 기준으로 오름차순 정렬
            if(o1[0] == o2[0]) return o1[1] - o2[1];
            return o1[0] - o2[0];
        });
        //3. 모든 좌표 쌍에 대해 확인하기
        for(int i = 0 ; i < n ; i++){
            //4. 첫번째 좌표의 x좌표
            int r1 = data[i][0];
            //5. 첫번째 좌표의 y좌표
            int c1 = data[i][1];
            for(int j = i+1 ; j < n ; j++){
                //6. 두번째 좌표의 x좌표
                int r2 = data[j][0];
                //7. 두번째 좌표의 y좌표
                int c2 = data[j][1];
                //8. 같은 행또는 열에 있는 경우는 지나감
                if(r1 == r2 || c1 == c2) continue;
                //9. 두 점 사이에 다른 점이 있는 지 확인하는 변수
                boolean check = true;
                //10. 두 점 사이에 다른 점이 있는 지 확인하는 반복문
                for(int k = i+1 ; k < j ; k++){
                    //11. 세번째 좌표의 x좌표
                    int r3 = data[k][0];
                    //12. 세번째 좌표의 y좌표
                    int c3 = data[k][1];
                    //13. 세번째 점이 두점 사이에 있는 경우
                    if((r1 < r3 && r3 < r2) && (Math.min(c1, c2) < c3 && c3 < Math.max(c1, c2))){
                        //14. 있는 경우에 check변수는 false
                        check = false;
                        break;
                    }
                }
                //15. 두 점 사이에 다른 점이 없는 경우는 결과값+1
                if(check) answer++;
            }
        }
        return answer;
    }
}
