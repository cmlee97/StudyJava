N개의 마을로 이루어진 나라가 있습니다. 이 나라의 각 마을에는 1부터 N까지의 번호가 각각 하나씩 부여되어 있습니다. 각 마을은 양방향으로 통행할 수 있는 도로로 연결되어 있는데, 서로 다른 마을 간에 이동할 때는 이 도로를 지나야 합니다.
도로를 지날 때 걸리는 시간은 도로별로 다릅니다. 현재 1번 마을에 있는 음식점에서 각 마을로 음식 배달을 하려고 합니다. 각 마을로부터 음식 주문을 받으려고 하는데, N개의 마을 중에서 K 시간 이하로 배달이 가능한 마을에서만 주문을 받으려고 합니다.
다음은 N = 5, K = 3인 경우의 예시입니다.

위 그림에서 1번 마을에 있는 음식점은 [1, 2, 4, 5] 번 마을까지는 3 이하의 시간에 배달할 수 있습니다. 그러나 3번 마을까지는 3시간 이내로 배달할 수 있는 경로가 없으므로 3번 마을에서는 주문을 받지 않습니다. 
따라서 1번 마을에 있는 음식점이 배달 주문을 받을 수 있는 마을은 4개가 됩니다.
마을의 개수 N, 각 마을을 연결하는 도로의 정보 road, 음식 배달이 가능한 시간 K가 매개변수로 주어질 때, 음식 주문을 받을 수 있는 마을의 개수를 return 하도록 solution 함수를 완성해주세요.

제한사항
마을의 개수 N은 1 이상 50 이하의 자연수입니다.
road의 길이(도로 정보의 개수)는 1 이상 2,000 이하입니다.
road의 각 원소는 마을을 연결하고 있는 각 도로의 정보를 나타냅니다.
road는 길이가 3인 배열이며, 순서대로 (a, b, c)를 나타냅니다.
a, b(1 ≤ a, b ≤ N, a != b)는 도로가 연결하는 두 마을의 번호이며, c(1 ≤ c ≤ 10,000, c는 자연수)는 도로를 지나는데 걸리는 시간입니다.
두 마을 a, b를 연결하는 도로는 여러 개가 있을 수 있습니다.
한 도로의 정보가 여러 번 중복해서 주어지지 않습니다.
K는 음식 배달이 가능한 시간을 나타내며, 1 이상 500,000 이하입니다.
임의의 두 마을간에 항상 이동 가능한 경로가 존재합니다.
1번 마을에 있는 음식점이 K 이하의 시간에 배달이 가능한 마을의 개수를 return 하면 됩니다.

//다익스타라 문제
//해당 마을 부터 다른 마을까지 갈 수 있는 최소 거리를 구한 뒤에, k보다 같거나 작은 경우만 구한다
//A를 시작점으로 했을때 다른도시까지의 거리에 대한 정보를 dist[]배열로 선언하여 초기화 한다 ex) 길이 존재하면 해당 값을, 존재하지 않으면 무한대값으로
//다른 도시 방문여부 visited[]배열 선언
//시작점을 제외하고 dist[]값이 가장 작은 도시의 index를 가져오고
//해당 index를 visited로 처리한후 index의 도시를 거쳐가는 경로가 원래 dist[]에 들어있는 값보다 작으면 그 값을 변경
//n-1번 반복

class Solution {
    public int solution(int N, int[][] road, int K) {
        int answer = 0;
        
        int[][] map = new int[N+1][N+1];
        
        //1. 배열을 무한으로 초기화
        for(int i = 1 ; i <= N ; i++){
            for(int j = 1 ; j <= N ; j++){
                if(i==j) continue;
                //2. 무한의 값은 500001로 함 -> 최대노드개수 * 간선의 최대 weight = 50*10000+1
                map[i][j] = 500001;
            }
        }
        
        //3. 이중배열을 통해 주어진 road 정보를 저장
        for(int i = 0 ; i < road.length ;i++){
            int a = road[i][0];
            int b = road[i][1];
            int w = road[i][2];
            
            if(map[a][b] > w){
                map[a][b] = w;
                map[b][a] = w;
            }
        }
        //4. 다른 도시까지의 거리 정보를 dist 배열로 선언하여, 초기화 하기
        int[] dist = new int[N+1];
        for(int i = 2 ; i <= N ; i++){
            dist[i] = (dist[i]==0) ? 500001 : map[1][i];
        }
        //5. 다른 도시 방문여부 체크 visited배열 선언
        boolean[] visited = new boolean[N + 1];
        visited[1] = true;
        
        for(int i = 1 ; i <= N - 1 ; i++){
            int min_index = 1;
            int min_value = 500001;
            for(int j = 2 ; j <= N ; j++){
                //6. dist에서 방문하지 않았고, 가장 작은 값을 가지는 index를 찾기
                if(!visited[j] && dist[j] < min_value){
                    min_value = dist[j];
                    min_index = j;
                }
            }
            visited[min_index] = true;
            //6. 거쳐가는 경로가 더 빠른지 확인하기
            for(int j = 2 ; j <= N ; j++){
                if(dist[j] > dist[min_index] + map[min_index][j]){
                    dist[j] = dist[min_index] + map[min_index][j];
                }
            }
        }
        //answer개수 찾기
        for(int i = 1 ; i <= N ; i++){
            if(dist[i] <= K) answer++;
        }
        return answer;
    }
}



다익스트라(Dijkstra) 알고리즘 : 다이나믹 프로그래밍을 활용한 대표적은 최단경로(Shortest Path) 탐색 알고리즘이다. 흔히 인공위성 GPS소프트웨어 등에서 가장 많이 사용됨
                              특정한 하나의 정점에서 다른 모든 정점으로 가는 최단경로를 알려주며, 이때 음의 간선은 포함 할 수 없음   
                              하나의 최단거리를 구할 때 그 이전까지 구했던 최단 거리 정보를 그대로 사용함
                              EX) 네비게이션, 미로탐색 알고리즘, 라우팅 OSPF방식의 프로토콜 등.
알고리즘 방식 (P[A][B]는 A와 B 사이의 거리라고 가정한다)
1. 출발점으로부터의 최단거리를 저장할 배열 d[v]를 만들고, 출발 노드에는 0을, 출발점을 제외한 다른 노드들에는 매우 큰 값 INF를 채워 넣기 (정말 무한이 아닌, 무한으로 간주될 수 있는 값을 의미한다.) 
2. 보통은 최단거리 저장 배열의 이론상 최대값에 맞게 INF를 정하기. 실무에서는 보통 d의 원소 타입에 대한 최대값으로 설정
3. 현재 노드를 나타내는 변수 A에 출발 노드의 번호를 저장
4. A로부터 갈 수 있는 임의의 노드 B에 대해, d[A] + P[A][B][4]와 d[B][5]의 값을 비교. INF와 비교할 경우 무조건 전자가 작음
5. 만약 d[A] + P[A][B]의 값이 더 작다면, 즉 더 짧은 경로라면, d[B]의 값을 이 값으로 갱신
6. A의 모든 이웃 노드 B에 대해 이 작업을 수행
7. A의 상태를 "방문 완료"로 바꾼 후 사용하지않음 EX) visited배열을 통해 boolean 값으로 저장
8. "미방문" 상태인 모든 노드들 중, 출발점으로부터의 거리가 제일 짧은 노드 하나를 골라서 그 노드를 A에 저장
9. 도착 노드가 "방문 완료" 상태가 되거나, 혹은 더 이상 미방문 상태의 노드를 선택할 수 없을 때까지, 3~7의 과정을 반복
10. 이 작업을 마친 뒤, 도착 노드에 저장된 값이 바로 A로부터의 최단 거리이며, 만약 이 값이 INF라면, 중간에 길이 끊긴 것임을 의미
구현
1. 배열 내에서 선형탐색 + 배열 내에 중복정점 허용하지 않음 (가장 빠름)
2. 우선순위큐 내에서 최솟값 탐색 후 큐 내에 중복 정점 허용하지 않음
3. 우선순위큐 내에서 최솟값을 탐색 후 큐 내에 중복 정점 허용

























